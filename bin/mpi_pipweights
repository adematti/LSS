#!/usr/bin/env python
"""
Compute PIP weights or generate alternate mtls in parallel

Example run at NERSC:

If calculating PIP weights:

srun -N 16 -c 8 -C haswell -A desi --qos=interactive -t 0:30:0 mpi_pipweights
     --mtl LRG_oneperztrue_clus.dat.fits --randoms LRG_oneperztrue_clus.ran.fits
     --format hdf5 --outdir output --realizations 128

If writing alternate mtl and/or fba files:

srun -N 10 -C haswell -A desi --qos=interactive -t 0:30:0 mpi_pipweights
     --mtl LRG_oneperztrue_clus.dat.fits --outdir output --realizations 10
     --mtlout --fbaout --nopip

Notes:
- Runs on master version of fiberassign, etc.
- Must add path_to_LSS_repo/LSS/bin to $PATH and path_to_LSS/LSS/py to $PYTHONPATH
- If calculating PIP weights:
  - PIP weights are stored as 64 bit integers, so the number of realizations must
    be a multiple of 64 (i.e. 64, 128, 192, etc. realizations correspond to output
    arrays BITWEIGHT0, BITWEIGHT1, BITWEIGHT2, etc.)
  - n nodes (-N) x n cpus (-c) must be a factor of the number of realizations

Required Arguments:
  mtl (str) : target fits file containing TARGETID, RA, DEC, Z

Optional Arguments:
  randoms      (str) : randoms fits file containing RA, DEC, Z (needed for PIP weights)
  sky          (str) : fits file containing sky targets
  footprint    (str) : fits file containing footprint
  tiles        (str) : text file containing tile IDs
  format       (str) : output file format (fits or hdf5)
  outdir       (str) : output directory
  realizations (int) : number of realizations
  mtlout      (bool) : output alternate mtl files
  fbaout      (bool) : output fiberassign files
  nopip       (bool) : turn off pip weights

Outputs:
  if calculating PIP weights:
    targeted.fits : fits (hdf5) file containing targeted science objects
    parent.fits   : fits (hdf5) file containing parent catalog
    randoms.fits  : fits (hdf5) file containing randoms catalog

  if generating alternate mtls:
    alt_mtl/mtl_{realization}.fits                    : alternate mtl file for each realization
    alt_fba/fiberassign_{realization}/fba-tileid.fits : fba file for each tile and realization
"""
import argparse

def parse():
    parser = argparse.ArgumentParser()
    parser.add_argument("--sky", type=str, required=False, help="fits file with sky targets")
    parser.add_argument("--mtl", type=str, required=True,
                        help="fits file with mtl, should contain only targets available to fibers")
    parser.add_argument("--randoms", type=str, required=False, help="fits file with random targets")
    parser.add_argument("--footprint", type=str, required=False, default=None,
                        help="Optional fits file defining the footprint, default footprint from desimodel")
    parser.add_argument("--tiles", type=str, required=False, default=None,
                        help="Optional text file containing a subset of the tile IDs to use in the footprint,"
                        "one ID per line. Default uses all tiles in the footprint.")
    parser.add_argument("--format", type=str, required=False, default="fits",
                        help="File format for outputs (either fits or hdf5)")
    parser.add_argument("--outdir", type=str, required=False, default=".", help="Output directory")
    parser.add_argument("--realizations", type=int, required=False, default=128, help="Number of realizations")
    parser.add_argument("--mtlout", action='store_true', required=False, default=False, help="write mtl files")
    parser.add_argument("--fbaout", action='store_true', required=False, default=False, help="write fba files")
    parser.add_argument("--nopip", action='store_true', required=False, default=False, help="turn off pip weights")

    args = parser.parse_args()
    return args

def main(args):
    # Initialize mpi
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    mpi_procs = comm.size
    mpi_rank = comm.rank

    import os
    import numpy as np
    from LSS.pipweights import (get_tiles, get_targets, setup_fba,
                               update_bitweights, pack_bitweights, write_output)
    from fiberassign.hardware import load_hardware
    from fiberassign.assign import run, write_assignment_fits

    # Get tile information
    tiles = get_tiles(args.tiles, args.footprint)

    # Get target and randoms information
    mtl, tgs, sky = get_targets(args.mtl, args.sky)
    tg_science = tgs.ids()
    n_target = len(tg_science)

    # Load hardward for fiber assignment
    hw = load_hardware()

    # Divide realizations among processes
    n_realization = args.realizations
    realizations = np.arange(n_realization, dtype=np.int32)
    my_realizations = np.array_split(realizations, mpi_procs)[mpi_rank]

    # Bit weight array for all targets and realizations
    bitweights = np.zeros(n_realization * n_target, dtype=bool)

    for realization in my_realizations:
        # Set the seed based on the realization, so that the result is reproducible
        # regardless of which process is working on the realization
        np.random.seed(realization)

        # Randomize science target subpriority
        mtl['SUBPRIORITY'] = np.random.random_sample(size=n_target)

        # Write alternate mtl file
        if args.mtlout:
            mtldir = os.path.join(args.outdir, 'alt_mtl')
            try:
                os.makedirs(mtldir)
            except: # already exists
                pass
            mtl.write('{}/mtl_{}.fits'.format(mtldir, realization))

        # Set up and run fiber assignment
        asgn = setup_fba(mtl, sky, tiles, hw)
        run(asgn)

        # Write fiberassign files
        if args.fbaout:
            fbadir = os.path.join(args.outdir, 'alt_fba', 'fiberassign_{}'.format(realization))
            write_assignment_fits(tiles, asgn, out_dir=fbadir)

        if not args.nopip:
            # Update bit weights for assigned science targets
            idas, bitweights = update_bitweights(realization, asgn, tiles, tg_science, bitweights)

    # Gather weights from all processes
    if not args.nopip:
        gather_weights = None
        if mpi_rank == 0:
            gather_weights = np.empty(len(bitweights), dtype=bool)
        min_targ = np.min(my_realizations) * n_target
        max_targ = (np.max(my_realizations) + 1) * n_target
        comm.Gather(bitweights[min_targ:max_targ], gather_weights, root=0)

    if mpi_rank == 0:
        # Pack weights into 64 bit integers
        if not args.nopip:
            weights = np.array_split(gather_weights, n_realization)
            bweights = np.array(weights).T
            bitvectors = pack_bitweights(bweights)

            # Load randoms
            randoms = Table.read(args.randoms)

            # Write output files
            write_output('targeted', args.outdir, args.format, mtl[idas], idas, bitvectors)
            write_output('parent', args.outdir, args.format, mtl, idas, bitvectors)
            write_output('randoms', args.outdir, args.format, randoms, idas, bitvectors)

if __name__ == "__main__":
    args = parse()
    main(args)
